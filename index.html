<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºæ…§å‹å¹³é¢åœ–æç©è¨ˆç®—å™¨ (OCRç‰ˆ)</title>
    <!-- å¼•å…¥ Tesseract.js ç”¨æ–¼æ–‡å­—è¾¨è­˜ -->
    <script src='https://unpkg.com/tesseract.js@v2.1.0/dist/tesseract.min.js'></script>
    <style>
        body { font-family: "Microsoft JhengHei", Arial, sans-serif; background-color: #f4f6f9; margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        
        h1 { color: #2c3e50; margin-bottom: 5px; }
        .subtitle { color: #7f8c8d; font-size: 0.9rem; margin-bottom: 20px; }
        
        /* å·¥å…·åˆ— */
        .toolbar { 
            background: white; padding: 15px; border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 15px; 
            display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;
            position: sticky; top: 10px; z-index: 100;
        }
        
        button { padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.95rem; transition: 0.2s; font-weight: bold; }
        .btn-primary { background-color: #3498db; color: white; }
        .btn-primary:hover { background-color: #2980b9; }
        .btn-success { background-color: #27ae60; color: white; }
        .btn-success:hover { background-color: #219150; }
        .btn-danger { background-color: #e74c3c; color: white; }
        .btn-warning { background-color: #f39c12; color: white; }
        
        /* æ¨¡å¼åˆ‡æ›é–‹é—œ */
        .mode-switch { display: flex; align-items: center; background: #eee; padding: 5px; border-radius: 20px; }
        .mode-option { padding: 5px 15px; border-radius: 15px; cursor: pointer; font-size: 0.9rem; user-select: none; }
        .mode-option.active { background: #3498db; color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }

        #file-input { display: none; }

        /* ä¸»è¦æ“ä½œå€ */
        .main-container { display: flex; gap: 20px; width: 100%; max-width: 1400px; flex-wrap: wrap; }
        
        /* å·¦å´ç•«å¸ƒ */
        .canvas-wrapper {
            flex: 2;
            min-width: 600px;
            position: relative;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            background-color: #fff;
            background-image: linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee), 
                              linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee);
            background-size: 20px 20px;
            overflow: auto;
            border: 2px solid #ddd;
        }
        canvas { display: block; cursor: crosshair; }

        /* å³å´æ•¸æ“šåˆ—è¡¨ */
        .data-panel {
            flex: 1;
            min-width: 300px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
        th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; }
        th { background: #f8f9fa; position: sticky; top: 0; }
        tr:hover { background: #f1f1f1; cursor: pointer; }
        .total-row { font-weight: bold; background: #e8f6f3; }

        /* è®€å–é®ç½© */
        #loading-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.8); z-index: 2000;
            justify-content: center; align-items: center; flex-direction: column;
        }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* å½ˆå‡ºè¦–çª— */
        #input-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 1000;
        }
        .modal-content { background: white; padding: 25px; border-radius: 8px; width: 320px; box-shadow: 0 10px 25px rgba(0,0,0,0.3); }
        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; margin-bottom: 4px; font-weight: bold; font-size: 0.9rem; }
        .form-group input { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
        .modal-footer { display: flex; justify-content: space-between; margin-top: 20px; }

    </style>
</head>
<body>

    <h1>ğŸ“ æ™ºæ…§å‹å¹³é¢åœ–æç©è¨ˆç®—å™¨</h1>
    <p class="subtitle">æ”¯æ´ï¼šæ‰‹å‹•æ¨™è¨» / OCR æ¡†é¸è¾¨è­˜ / é»æ“Šä¿®æ”¹ / å ±è¡¨å°å‡º</p>

    <div class="toolbar">
        <button class="btn-primary" onclick="document.getElementById('file-input').click()">ğŸ“ 1. å°å…¥å¹³é¢åœ–</button>
        <input type="file" id="file-input" accept="image/*" onchange="handleImageUpload(event)">
        
        <div class="mode-switch">
            <div class="mode-option active" id="mode-manual" onclick="setMode('manual')">ğŸ–ï¸ æ‰‹å‹•é»é¸</div>
            <div class="mode-option" id="mode-ocr" onclick="setMode('ocr')">ğŸ” OCR æ¡†é¸è¾¨è­˜</div>
        </div>

        <button class="btn-success" onclick="exportImage()">ğŸ’¾ å°å‡ºåœ–ç‰‡</button>
        <button class="btn-success" onclick="exportCSV()">ğŸ“Š å°å‡º Excel(CSV)</button>
        <button class="btn-danger" onclick="clearAll()">ğŸ—‘ï¸ å…¨éƒ¨æ¸…é™¤</button>
    </div>

    <div class="main-container">
        <!-- ç•«å¸ƒå€ -->
        <div class="canvas-wrapper" id="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>

        <!-- æ•¸æ“šåˆ—è¡¨å€ -->
        <div class="data-panel">
            <h3>ğŸ“¦ æç©æ˜ç´°è¡¨</h3>
            <table id="dataTable">
                <thead>
                    <tr>
                        <th>ç·¨è™Ÿ</th>
                        <th>å°ºå¯¸ (cm)</th>
                        <th>æç©</th>
                        <th>æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                    <!-- å…§å®¹å‹•æ…‹ç”Ÿæˆ -->
                </tbody>
                <tfoot>
                    <tr class="total-row">
                        <td colspan="2">ç¸½è¨ˆ</td>
                        <td id="totalVolume">0.00</td>
                        <td></td>
                    </tr>
                </tfoot>
            </table>
        </div>
    </div>

    <!-- ç·¨è¼¯/è¼¸å…¥ å½ˆçª— -->
    <div id="input-modal">
        <div class="modal-content">
            <h3 id="modal-title">å€‰ä½æ¨™è¨»</h3>
            <div class="form-group">
                <label>ç·¨è™Ÿ/åç¨±:</label>
                <input type="text" id="dim-name" placeholder="ä¾‹å¦‚: A-01">
            </div>
            <div class="form-group">
                <label>å¯¬ (Width):</label>
                <input type="number" id="dim-w">
            </div>
            <div class="form-group">
                <label>æ·± (Depth):</label>
                <input type="number" id="dim-d">
            </div>
            <div class="form-group">
                <label>é«˜ (Height):</label>
                <input type="number" id="dim-h">
            </div>
            <div style="font-size: 0.8rem; color: #666; margin-bottom:10px;">å…¬å¼: (W*D*H)/28317</div>
            
            <div class="modal-footer">
                <button class="btn-danger" id="btn-delete" style="display:none;" onclick="deleteMarker()">åˆªé™¤</button>
                <button class="btn-warning" onclick="closeModal()">å–æ¶ˆ</button>
                <button class="btn-success" onclick="saveMarker()">ç¢ºå®šå„²å­˜</button>
            </div>
        </div>
    </div>

    <!-- Loading é®ç½© -->
    <div id="loading-overlay">
        <div class="spinner"></div>
        <p id="loading-text">æ­£åœ¨è¾¨è­˜æ–‡å­—ä¸­...</p>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const modal = document.getElementById('input-modal');
        
        let bgImage = new Image();
        let markers = []; 
        let isImageLoaded = false;
        
        // ç‹€æ…‹è®Šæ•¸
        let currentMode = 'manual'; // 'manual' or 'ocr'
        let isDragging = false;
        let startX, startY, endX, endY;
        let editingIndex = -1; // -1 è¡¨ç¤ºæ–°å¢, å…¶ä»–æ•¸å­—è¡¨ç¤ºç·¨è¼¯é™£åˆ—ç´¢å¼•
        let tempCoords = {x:0, y:0}; // æ–°å¢æ™‚çš„åº§æ¨™

        // 1. åˆå§‹åŒ–èˆ‡åœ–ç‰‡ä¸Šå‚³
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                bgImage = new Image();
                bgImage.onload = function() {
                    canvas.width = bgImage.width;
                    canvas.height = bgImage.height;
                    isImageLoaded = true;
                    // è®“ç•«å¸ƒé©æ‡‰è¢å¹•ï¼Œä½†ä¿æŒå…§éƒ¨è§£æåº¦
                    fitCanvas();
                    redraw();
                }
                bgImage.src = event.target.result;
            }
            reader.readAsDataURL(file);
        }

        function fitCanvas() {
            // ç°¡å–®çš„éŸ¿æ‡‰å¼è™•ç†
            const container = document.getElementById('canvas-container');
            if(bgImage.width > container.clientWidth) {
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
            } else {
                canvas.style.width = '';
                canvas.style.height = '';
            }
        }

        // 2. æ¨¡å¼åˆ‡æ›
        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-option').forEach(el => el.classList.remove('active'));
            document.getElementById(`mode-${mode}`).classList.add('active');
            
            // æ”¹è®Šæ¸¸æ¨™æ¨£å¼
            canvas.style.cursor = mode === 'ocr' ? 'crosshair' : 'default';
        }

        // 3. Canvas æ»‘é¼ äº‹ä»¶è™•ç† (æ ¸å¿ƒé‚è¼¯)
        canvas.addEventListener('mousedown', function(e) {
            if (!isImageLoaded) return;
            const {x, y} = getCanvasCoordinates(e);

            // æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°ç¾æœ‰æ¨™è¨˜ (å„ªå…ˆæ¬Šæœ€é«˜)
            const clickedIndex = findClickedMarker(x, y);
            if (clickedIndex !== -1) {
                openModal(clickedIndex);
                return;
            }

            // å¦‚æœæ˜¯æ‰‹å‹•æ¨¡å¼ï¼Œç›´æ¥é»æ“Šæ–°å¢
            if (currentMode === 'manual') {
                tempCoords = {x, y};
                openModal(-1); // -1 ä»£è¡¨æ–°å¢
                return;
            }

            // å¦‚æœæ˜¯ OCR æ¨¡å¼ï¼Œé–‹å§‹æ¡†é¸
            if (currentMode === 'ocr') {
                isDragging = true;
                startX = x;
                startY = y;
            }
        });

        canvas.addEventListener('mousemove', function(e) {
            if (!isDragging || currentMode !== 'ocr') return;
            const {x, y} = getCanvasCoordinates(e);
            endX = x;
            endY = y;
            redraw(); // é‡ç•«ä»¥é¡¯ç¤ºé¸æ¡†
            
            // ç•«å‡ºç´…è‰²é¸æ¡†
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;
            ctx.setLineDash([6, 3]);
            ctx.strokeRect(startX, startY, endX - startX, endY - startY);
            ctx.setLineDash([]);
        });

        canvas.addEventListener('mouseup', function(e) {
            if (!isDragging) return;
            isDragging = false;
            
            // è¨ˆç®—é¸å–å€åŸŸ
            const w = Math.abs(endX - startX);
            const h = Math.abs(endY - startY);
            
            // é˜²æ­¢èª¤è§¸å¾®å°ç§»å‹•
            if (w < 10 || h < 10) return;

            // å®šç¾©æœ€çµ‚é¸å–å€å·¦ä¸Šè§’
            const rectX = Math.min(startX, endX);
            const rectY = Math.min(startY, endY);
            
            tempCoords = {x: rectX, y: rectY};
            
            // åŸ·è¡Œ OCR
            performOCR(rectX, rectY, w, h);
        });

        // è¼”åŠ©ï¼šå–å¾—åœ¨ Canvas ä¸Šçš„çœŸå¯¦åº§æ¨™
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        // 4. OCR è¾¨è­˜é‚è¼¯
        async function performOCR(x, y, w, h) {
            showLoading(true);

            // å‰µå»ºä¸€å€‹è‡¨æ™‚ canvas ä¾†è£åˆ‡åœ–ç‰‡
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const tCtx = tempCanvas.getContext('2d');
            
            // å¾åŸåœ–è£åˆ‡
            tCtx.drawImage(bgImage, x, y, w, h, 0, 0, w, h);
            
            // åœ–åƒå¢å¼· (ç°¡å–®äºŒå€¼åŒ–ï¼Œæé«˜ OCR æº–ç¢ºç‡) - éå¿…é ˆä½†å»ºè­°
            // é€™è£¡ç‚ºäº†ç°¡åŒ–ç›´æ¥å‚³é€åœ–åƒ
            
            try {
                // ä½¿ç”¨ Tesseract.js
                const result = await Tesseract.recognize(tempCanvas, 'eng');
                const text = result.data.text;
                
                // åˆ†ææ–‡å­—æŠ“å–æ•¸å­—
                // ä½¿ç”¨ Regex æŠ“å–æ‰€æœ‰æ•¸å­—
                const numbers = text.match(/\d+/g);
                
                let detectedW = '', detectedD = '', detectedH = '';
                
                if (numbers && numbers.length >= 3) {
                    detectedW = numbers[0];
                    detectedD = numbers[1];
                    detectedH = numbers[2];
                } else if (numbers && numbers.length === 2) {
                    detectedW = numbers[0];
                    detectedD = numbers[1];
                }

                showLoading(false);
                
                // é–‹å•Ÿå½ˆçª—ä¸¦é å¡«è³‡æ–™
                openModal(-1); // æ–°å¢æ¨¡å¼
                document.getElementById('dim-w').value = detectedW;
                document.getElementById('dim-d').value = detectedD;
                document.getElementById('dim-h').value = detectedH;
                
                // è‡ªå‹•ç”Ÿæˆåç¨±
                document.getElementById('dim-name').value = `Pos-${markers.length + 1}`;

            } catch (err) {
                showLoading(false);
                alert("OCR è¾¨è­˜å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¼¸å…¥");
                openModal(-1);
            }
        }

        // 5. æ¨™è¨˜ç®¡ç† (CRUD)
        function openModal(index) {
            editingIndex = index;
            modal.style.display = 'flex';
            const deleteBtn = document.getElementById('btn-delete');
            const title = document.getElementById('modal-title');

            if (index === -1) {
                // æ–°å¢æ¨¡å¼
                title.innerText = "æ–°å¢å€‰ä½æ¨™è¨»";
                deleteBtn.style.display = 'none';
                // å¦‚æœä¸æ˜¯ OCR è‡ªå‹•å¡«å…¥çš„ï¼Œæ¸…ç©º
                if (currentMode === 'manual') {
                    document.getElementById('dim-name').value = `A-${markers.length + 1}`;
                    document.getElementById('dim-w').value = '';
                    document.getElementById('dim-d').value = '';
                    document.getElementById('dim-h').value = '';
                }
            } else {
                // ç·¨è¼¯æ¨¡å¼
                title.innerText = "ä¿®æ”¹å€‰ä½æ¨™è¨»";
                deleteBtn.style.display = 'block';
                const m = markers[index];
                document.getElementById('dim-name').value = m.name;
                document.getElementById('dim-w').value = m.w;
                document.getElementById('dim-d').value = m.d;
                document.getElementById('dim-h').value = m.h;
            }
            
            // è‡ªå‹•èšç„¦
            document.getElementById('dim-w').focus();
        }

        function closeModal() {
            modal.style.display = 'none';
            redraw(); // æ¸…é™¤å¯èƒ½æ®˜ç•™çš„é¸æ¡†
        }

        function saveMarker() {
            const w = parseFloat(document.getElementById('dim-w').value);
            const d = parseFloat(document.getElementById('dim-d').value);
            const h = parseFloat(document.getElementById('dim-h').value);
            const name = document.getElementById('dim-name').value || 'æœªå‘½å';

            if (isNaN(w) || isNaN(d) || isNaN(h)) {
                alert("è«‹è¼¸å…¥å®Œæ•´çš„é•·å¯¬é«˜æ•¸å­—");
                return;
            }

            const volume = ((w * d * h) / 28317).toFixed(2);
            
            const markerData = {
                x: editingIndex === -1 ? tempCoords.x : markers[editingIndex].x,
                y: editingIndex === -1 ? tempCoords.y : markers[editingIndex].y,
                w: w, d: d, h: h,
                name: name,
                volume: volume,
                text: `${volume} æ`
            };

            if (editingIndex === -1) {
                markers.push(markerData);
            } else {
                markers[editingIndex] = markerData;
            }

            updateTable();
            redraw();
            closeModal();
        }

        function deleteMarker() {
            if (editingIndex !== -1) {
                if(confirm("ç¢ºå®šè¦åˆªé™¤æ­¤æ¨™è¨˜å—ï¼Ÿ")) {
                    markers.splice(editingIndex, 1);
                    updateTable();
                    redraw();
                    closeModal();
                }
            }
        }

        function findClickedMarker(x, y) {
            // å€’åºæª¢æŸ¥ï¼Œç¢ºä¿é»åˆ°æœ€ä¸Šå±¤çš„æ¨™ç±¤
            for (let i = markers.length - 1; i >= 0; i--) {
                const m = markers[i];
                // ç°¡å–®çš„ç¢°æ’æª¢æ¸¬ (å‡è¨­æ¨™ç±¤å¯¬é«˜ç´„ç‚º 120x60ï¼Œå¯è¦–æƒ…æ³èª¿æ•´)
                // é€™è£¡æˆ‘å€‘ç›´æ¥è¨ˆç®—æ–‡å­—å¯¬åº¦æœƒæ›´ç²¾æº–ï¼Œä½†ç°¡åŒ–ç‰ˆç”¨å›ºå®šå€åŸŸæª¢æ¸¬
                if (x >= m.x && x <= m.x + 120 && y >= m.y && y <= m.y + 60) {
                    return i;
                }
            }
            return -1;
        }

        // 6. ç¹ªåœ–èˆ‡è¡¨æ ¼æ›´æ–°
        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (isImageLoaded) {
                ctx.drawImage(bgImage, 0, 0);
            }
            markers.forEach(drawMarker);
        }

        function drawMarker(m) {
            const padding = 8;
            const fontSize = 24; 
            ctx.font = `bold ${fontSize}px Microsoft JhengHei`;
            
            const textWidth = ctx.measureText(m.text).width;
            const boxWidth = Math.max(textWidth + 20, 100);
            const boxHeight = 60;

            // ç•«æ¨™ç±¤åº•è‰²
            ctx.fillStyle = "rgba(44, 62, 80, 0.85)";
            ctx.beginPath();
            ctx.roundRect(m.x, m.y, boxWidth, boxHeight, 5);
            ctx.fill();

            // ç•«æç© (é†’ç›®)
            ctx.fillStyle = "#f1c40f";
            ctx.fillText(m.text, m.x + padding, m.y + fontSize + 5);

            // ç•«å°ºå¯¸ (å°å­—)
            ctx.fillStyle = "#ecf0f1";
            ctx.font = `14px Microsoft JhengHei`;
            ctx.fillText(`${m.name} (${m.w}x${m.d}x${m.h})`, m.x + padding, m.y + fontSize + 22);
            
            // ç•«ç´…é»
            ctx.beginPath();
            ctx.arc(m.x, m.y, 4, 0, 2 * Math.PI);
            ctx.fillStyle = "#e74c3c";
            ctx.fill();
        }

        function updateTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            let total = 0;

            markers.forEach((m, index) => {
                total += parseFloat(m.volume);
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${m.name}</td>
                    <td>${m.w} x ${m.d} x ${m.h}</td>
                    <td><strong>${m.volume}</strong></td>
                    <td><button style="padding:2px 8px; font-size:0.8rem;" onclick="deleteFromTable(${index})">âŒ</button></td>
                `;
                // é»æ“Šè¡¨æ ¼ä¹Ÿèƒ½ç·¨è¼¯
                tr.onclick = (e) => {
                    if(e.target.tagName !== 'BUTTON') openModal(index);
                };
                tbody.appendChild(tr);
            });

            document.getElementById('totalVolume').innerText = total.toFixed(2);
        }

        function deleteFromTable(index) {
            event.stopPropagation();
            markers.splice(index, 1);
            updateTable();
            redraw();
        }

        function clearAll() {
            if(confirm("ç¢ºå®šæ¸…ç©ºæ‰€æœ‰æ•¸æ“šï¼Ÿ")) {
                markers = [];
                updateTable();
                redraw();
            }
        }

        // 7. å°å‡ºåŠŸèƒ½
        function exportImage() {
            if (!isImageLoaded) return;
            const link = document.createElement('a');
            link.download = 'æç©æ¨™è¨»åœ–.png';
            link.href = canvas.toDataURL("image/png");
            link.click();
        }

        function exportCSV() {
            if (markers.length === 0) {
                alert("æ²’æœ‰è³‡æ–™å¯å°å‡º");
                return;
            }
            // è£½ä½œ CSV å…§å®¹ (åŠ ä¸Š BOM ä»¥è§£æ±º Excel ä¸­æ–‡äº‚ç¢¼)
            let csvContent = "\uFEFFç·¨è™Ÿ,å¯¬(cm),æ·±(cm),é«˜(cm),æç©(cuft)\n";
            markers.forEach(m => {
                csvContent += `${m.name},${m.w},${m.d},${m.h},${m.volume}\n`;
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "å€‰ä½æç©è¡¨.csv");
            link.click();
        }

        // UI è¼”åŠ©
        function showLoading(show) {
            document.getElementById('loading-overlay').style.display = show ? 'flex' : 'none';
        }

        // ç›£è½éµç›¤ Enter
        modal.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') saveMarker();
        });

    </script>
</body>
</html>